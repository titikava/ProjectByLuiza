package uroki.myclass090523;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;

//----------------------------------ArrayList
/*
 * Java представляет специальные классы для хранения и управения группами объектов. Один из этих классов- ArrayList.
 * Стандартные Java массивы имеют фиксированную длинну, что означает что после их создания они не могут быть расширены или уменьшены.
 * ArrayList создается с определенным первоначальным размером, но если мы добавляем элементы, то его длина автоматически
 * увеличивается/уменьшается.
 *
 * Коллекции в общем виде - это возможность собрать объекты в некоторую группу (множество) и работать с этой группой.
 * Коллекция предоставляет возможжность совершать операции с группой объектов. Это добавление/удаление/просмотр всех объектов
 * в группе и прочее более специализированные операции.
 *
 * Когда объекты удаляются ArrayList может уменьшаться в размере. ArrayList находится в пакете java.util
 * Его необходимо импортировать.
 *
 * Методы ArrayList:
 * 1. add() - добавляет новые объекты
 * 2. remove() - удаляет объекты
 * 3. contains() - возвращает булевое значение содержит ли список элемент в круглых скобках
 * 4. size() - возвращает число элементов в списках (индексирование как в массивах - с нуля)
 * 5. clear() - очищает массив т.е. удаляет все элементы
 * 6. get(int index) - возвращает элемент на указанной позиции в списке
 *
 * ------------------------LinkedList
 * LinkedList похож по синтаксису на ArrayList. Можно легко заменить LinkedList на ArrayList
 * Но вы не можете определить начальный размер для LinkedList
 * Наиболее заметная разница между LinkedList и ArrayList находится в их способах хранения объектов.
 * ArrayList лучше для храенния и получения доступа к информации т.к. он очень похож на обычный массив.
 * LinkedList лучше для манипулирования информацией - для вставок и удалений.
 * В дополнении к хранению объекта LinkedList хранит адрес памяти или ссылку элемента, который следует за ним.
 * Он называется LinkedList(связанный список) потому что каждый элемент содержит ссылку на соседний элемент.
 * [12[ссылка на след]] --> [99[ссылка на след]] --> [32[ссылка на след]] --> [x]
 *
 * В итоге используйте ArrayList, когда вам необходим быстрый доступ к вашей информации.
 * Используйте LinkedList, когда вам необходимо сделать большое кол-во вставок и/или удалений.
 *
 *
 * ---------------------------HashMap
 * Массивы и списки хранят элементы в виде упорядоченных коллекций. Каждый элемент с заданным целочисленным индексом.
 * HashMap используется для хранения коллекции информации в виде пар - ключи и значения. Один объекты используется в
 * качестве ключа к другому объекту.
 * Методы:
 * 1. put() - добавление объекта
 * 2. remove() - удаление объекта
 * 3. get(ключ) - получение объекта
 * 4. containsKey() - определяет наличие соответствующего ключа
 * 5. containsValue() - определяет наличие соответствующего значения. Если попытаться получить значение/ключ которого нет,
 * то вернет null
 * HashMap не может содержать дубликаты ключей. Добавления нового пункта с существующим ключем переписывает старый элемент.
 *
 * --------------------Set
 * Set это коллекция, которая не может содержать дубликаты элементов. Она моделирует математический набор абстракций.
 * Одной из ее реализаций является класс HashSet.
 * Вы можете использовать метод size для получения кол-ва элементов.
 *
 *
 * ----------------------LinkedHashSet
 * Класс HashSet не сохраняет автоматический порядок элементов, который вы добавили. Что бы упорядочить элементы
 * используйте LinkedHashSet, который сохраняет порядок элементов в котором они были добавлены.
 *
 *
 * ------------------------------------------
 * 1. java.util.Collection - основной интерфейс, который описывает базовые методы, которыми должна обладать любая коллекция.
 * Т.е. если какой-то класс претендует на звание коллекция, то он должен реализовать те методы, которые описаны в этом интерфейсе
 * 2. java.util.List - интерфейс для операци с коллекцией, которая является списком. Список обладает следующими важными признаками:
 * -список может включать одинаковые элементы
 * -элементы в списке хранятся в том порядке, к вотором они помещаются. Самопроизвольное перемещение элементов в нем
 * не происходит, только с вашего ведома. Например вы можете добавить элемент на какую-то позицию и тогда произойдет
 * сдвиг других элементов
 * -можно получить доступ к любому элементу по его индексу
 * 3. java.util.Set - интерфейс для хранения множества. В отличии от java.util.List этот интерфейс не может иметь одинаковые
 * элементы. И порядок хранения элементов в множетстве может меняться при добавлении, удалении, изменении элемента. Такая
 * коллекция нужна в случае, если вы создаете уникальный набор элементов из какой-то группы элементов.
 * 4. java.util.SortedSet - наследник интерфейса java.util.Set. Его дополнительным функционалом является автоматическое
 * выстраивание элементов внутри множества по порядку.
 * 5. java.util.Queue - интерфейс предлагает работать с коллекциями как с очередью. Т.е. коллекция имеет метод для добавления жлемента в один конец
 * и метод для получения элементов с другого конца. FIFO (FirstInputFirstOutput)
 * 6. java.util.Map - удобная конструкция, которая хранит данные не в виде списка а в виде пар ключ-значение. Это востребованная форма
 * в которой вы получаете доступ к значению в коллекции по ключу. Например доступ к данным пользователя на сайте может быть осуществлен по
 * логину или email.
 *
 * Мы сами выбираем путь
 * */
public class MyClass090523 {

    public static void main(String[] args) {
        ArrayList<String> array1 = new ArrayList<String>(10); //длину можно указывать/можно не указывать
        ArrayList<Integer> array2 = new ArrayList<Integer>(); //необходимо указывать именно класс, т.е. не int а Integer (к примеру)
        ArrayList<ArrayList<Integer>> arrayMatrix = new ArrayList<ArrayList<Integer>>();

//        ArrayList<String> colorList = new ArrayList<>();
//        LinkedList<String> colorList = new LinkedList<>();
//        colorList.add("Red");
//        colorList.add("Blue");
//        colorList.add("Green");
//        colorList.add("Grey");
//        colorList.add("Yellow");
//        System.out.println(colorList);
//        colorList.remove("Blue");
//        System.out.println(colorList);
//        System.out.println(colorList.get(0));
//        System.out.println(colorList.size());
//        if (colorList.contains("Red")) System.out.println("contains red");
//        if (!colorList.isEmpty()) System.out.println("not empty");
//
//        HashMap<String, Integer> points = new HashMap<>();
//        points.put("One", 1);
//        points.put("Two", 2);
//        points.put("Three", 3);
//        points.put("Four", 4);
//        points.put("Five", 5);
//        points.put("Two", 55);
//        System.out.println(points.get("Two"));
//        System.out.println(points);
//        if (points.containsValue(5)) System.out.println("Yes");
//        if (!points.containsKey("Six")) System.out.println("Not contains key six");

        HashSet<Integer> set1 = new HashSet<>();
        set1.add(1);
        set1.add(2);
        set1.add(3);
        set1.add(4);
        set1.add(5);
        set1.add(1);
        System.out.println(set1);
    }
}
