package uroki;

import lessonOOP.Pear;
import lessonOOP.Person;

/*Внутренние классы
Внутренние классы создаются внутри существующего класса. В отличие от обычных классов могут быть приватными.(К нему не смогут
получить доступ объекты, лежащие вне класса. Смотрите класс Robot

Анонимные классы
Анонимные классы являются способом расширения существующих классов.

Сравнение (equals)
Как делать?
Правый клик мыши по пустому пространству --> generate --> equals and hashCode --> All next
Можно переопределять метод equals для каждого класса, учитывая ваши предпочтения для сравнения определенных объектов

Метод hashCode для определения где внутренне хранить объект.
hashCode возвращает цифровое значение фиксированной длины для любого объекта. В Java hashCode возвращает число типа int
Сравнивать два числа намного проще, чем множества атрибутов объектов класса
Метод hashCode так же переопределяется в каждом классе по усмотрению разработчика
Официальные требования прописаны в документации Oracle (на английском =(() для методов equals и hashCode
1. Если два объекта равны (т.е. метод equals возвращает true), то у них должен быть одинаковый hashCode. Иначе наши методы будут лишены смысла.
Проверка по hashCode должна идти первой для повышения быстродействия. Если hashCode будут разные, то проверка вернет false.
Хотя объекты на самоом деле равны, согласно equals.
2. Если метод hashCode вызывается несколько раз на одном и том же объекте, то он должен возвращать тоже число.
3. Правило 1 не работает в обратную сторону. Одинаковый hashCode может быть у двух раззных объектов. Как так?
Метод hashCode возвращает число int. int - 32х битное число (диапазон от -2млрд до +2млрд). Примерно 4,5 млрд вариантов.
Предположим что мы хотим создать класс человек и посчитать всех людей на планете. Всего 7.5 млрд, а инт вмещает 4,5 млрд.
Т.е. возможны случаи, что некоторые будут совпадать. Такая ситуация (совпадение hashCode) называется коллизией. Одна из задач
программиста при переопределении метода hashCode сократить число коллизий. Как будет выглядить наш hashCode для класса Person.
Всякий раз, когда мы переопределяем метод equals мы должны переопределить метод hashCode

Перечисления
Enum - специальный тип, для определения коллекция констант.
*/
public class MyClass070423 {



    public static void main(String[] args) {

        Robot070423 robot1 = new Robot070423(1);
        Machine070423 m = new Machine070423() {
            @Override
            public void start() {
                System.out.println("gogogo");
            }
        };
        m.start();

        Person person1 = new Person("Игорь", 18);
        Person person2 = new Person("Игорь", 18);
        person2.setRank(Rank070423.SERGEANT);
        Person person3 = new Person("Игорь", 18);
        Person person4 = new Person("Игорь", 18);
        Pear pear1 = new Pear();
        System.out.println(person1.equals(person2) && person3.equals(pear1));

    }

    public static void enumExample() {
        String a = String.valueOf(Rank070423.CAPTAIN);
        Rank070423 b = Rank070423.SOLDIER;
        switch (b) {
            case SOLDIER -> System.out.println("Hello!");
            case CAPTAIN -> System.out.println("I'm captain");
            case SERGEANT -> System.out.println("I'm sergeant");
        }
    }
}
