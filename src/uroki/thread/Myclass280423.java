package uroki.thread;

/* Потоки, многопоточность в java
Многопоточность это способность процесса независимо выполнять процессы или потоки. Все программы выполняются
потоками.
Поток - это легковесный подпроцесс, наименьшая единица обработки.

Преимущества многопоточности:
1. С использованием многопоточности можно разрабатывать более адаптивные приложения: мы можем выполнять несколько
операций одновремено. Например - скачивание некоторых ресурсов и общение в чате одновременно.
2. Мы можем добиться лучшего использования ресурсов: по умолчанию программа java являеться однопоточной
3. Общая производительность может быть увеличена в несоклько раз

Недостатки многопоточности:
1. Потоки манипулируют данными, расположенными в одной и той же памяти, принадлежат одному и тому же процессу и
необходимо обеспечивать синхронизацию и согласованность данными между потоками.
2. Довольно сложно проектировать многопоточные приложения и трудно отлаживать в случае ошибок.
3. Когда потоков много процессу приходится переключаться между потоками. Этот процесс называется переключением
контекста. Переключение между потоками - дорогостоящая операция, поскольку процессор должен сохранять локальные
данные одного потока и загружать локальные данные другого потока. В конечном счете общая производительность пострадает
а не улучшиться, если будет слишком много потоков.

В java существует два типа потоков - пользовательские (которые мы создаем) и потоки-демоны. Когда запускается java программа
сразу начинает выполняться один поток - основной. Основной поток запускает метод main. Потоки-демоны в основном функционируют
как вспомогательные потоки. Они выполняют разные операции в фоновом режиме. Например Garbage Collection в java выполняется
в фоновом режиме как поток-демон. Что бы превратить обычный поток в поток-демон в Thread есть метод setDaemon.

Многопоточность в java предоставляет базовый клас Thread. Существует два способа создания потоков - при помощи наследования
от Thread, либо реализация интерфейса Runnable.

---------------------------------------------------------------------------------------------------------------------
Ожидание завершения потока.
В нашем случае Main thread завершился до доченего потока. Как правило более распространенная ситуация - является когда
main thread завершается самым последним. Для этого нам надо применить метод join(); В этом случае текущий поток будет
ожидать завершение потока, для которого вызван метод join();

---------------------------------------------------------------------------------------------------------------------
Каждый поток прибывает в одном из следующих состояний:
-Создан (new)
-Запущен (runnable)
-Заблокирован (blocked)
-Завершен (terminated)
-Ожидает (waiting)

*/

public class Myclass280423 {
    public static void main(String[] args) throws InterruptedException {



        /* System.out.println("Main thread started");
        Thread threadExampleRunnable1 = new Thread(new ThreadExampleRunnable(), "Boba");
        threadExampleRunnable1.start();
        System.out.println("Main thread finish");
            */
        /*
        System.out.println("Main thread started");
        ThreadExample threadExample1 = new ThreadExample("Bibo");
        threadExample1.start();
        threadExample1.join();
        System.out.println("Main thread finish");
*/
       /*
        System.out.println("Main thread started");
        for (int i = 1; i <= 6; i++) {
            new ThreadExample("Thread" + i).start();
        }
        System.out.println("Main thread finish");
        */
    }
}
